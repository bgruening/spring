#!/usr/bin/env python
"""
Module for using spring to predict genome wide protein protein interactions.
The Module runs in three stages. First HHsearch is ran on all the protein in 
the genome to identify templates in the pdb using the ./source/hhsearch.py 
module. Using the command:
hhsearch.py -q proteinList -iDir /input/Directory -genome -make -search -job
Next the results are concatenated using this modules summary option. ie
springGenome.py -q proteinList -r GetSummary -iDir /input/Directory/
Finally all pairwise interactions are evaluated using.
springGenome.py -q proteinList -r PredictInteractions -iDir /input/Directory/

proteinList is the full path to a newline delimeted list of protein names.
"""
#python 2.x and 3.x cross compatibility
from __future__ import print_function, division
import sys
if sys.version_info[0] >= 3:
    xrange = range


#python libraries
import os
from operator import itemgetter
import shutil
import argparse
import pandas as pd

#user libraries
import springConfig
sys.path.append( springConfig.parameters['jobPath'] )
sys.path.append( springConfig.parameters['commandPath'])
sys.path.append( springConfig.parameters['hhsearchPath'])
from jobsubmit import JOBS
from hhfunctions import HHSEARCH_Functions
from commandfunctions import Execute, mkdirs, mkdir, RemoveDirectory

class SPRING_GENOME:
    """
    This class contains the methods for running genome wide protein protein
    interaction prediction

    Attributes:
        user: username
        query: The target ie 12asA-12asB or the full path of a file containing 
            a list of targets.
        inputDirectory: Full path to where the fasta, hhm, and hhr directory
            are located
        hhrPath: Full path to where hhsearch results files are located. ie
            inputDirectory/hhr/
        interactionDir: Full path to where interaction predictions for each 
            protein are located.  ie inputDirectory/spring_interactions/
        RefCoreToChain: A dictionary that chains in monomer library to 
            consituents in the complex library
        BioMol: A dicitionary containing all the names of complex interactions 
            in the PDB
        indexFile: The path to the index file
        variableName: Name of variable used for screening.  The options can 
            be found in springConfig.py in genomeParameters and 
            genomeVariableName
        variableCutoff: The cutoff value used for identifying significant hits
            from hhsearch.  The default values can be found in springConfig.py
            under the dicitionary genomeParameters and the value used in this
            script is in springCongig.py as genomeVariableCutoff
        substrPos: Start of substring from protein file name. Used for creating 
            a substring from each protein name.  The substring is used as a name
            for the subdirectory containing the file of interests.  This helps
            keep the directory sizes managable.
        substrLen: Length of substring used from protein file name. Used for 
            creating a substring from each protein name.  The substring is used 
            as a name for the subdirectory containing the file of interests.  
            This helps keep the directory sizes managable.
    Methods:
        CreateSummaryFile: Reads all hhr files and generates a file that 
            summarizes the results.  Allows for faster parsing when
            the genome wide interaction predictions is conducted.
        RunSpringGenome: Main function for using spring to predict
            all pairwise interactions.
        StoreSummary: Stores summary file generated by CreateSummaryFile
        StoreIndex: Stores spring index file.
        SearchIndex: Uses spring index file to quickly screen for 
            possible protein interactions
        ExtractInteractions: Extracts results and remove redundancies
            generated from running SearchIndex running the pairwise
            comparision in both orders.
        WriteOutput: If a protein is predicted to have interactions
            with another protein a file is written to spring.interactions
            directory containing all predicted interactions.
        WriteOutputSummary: Write to file all pairwise interactions
            represented by its most confident complex template.
    """
    def __init__(self,query,inputDirectory):
        self.user = springConfig.parameters['user']
        self.query = query
        self.inputDirectory = inputDirectory
        self.hhrPath = inputDirectory+'/hhr/'
        self.interactionsDir = inputDirectory+'/spring_interactions/'
        self.RefCoreToChain = {}
        self.BioMol = {}
        self.indexFile = springConfig.genomeIndexFile
        self.variableName = springConfig.genomeVariableName
        self.variableCutoff =  springConfig.genomeVariableCutoff
        self.substrPos = springConfig.PDBparameters['substrPosition']
        self.substrLen = springConfig.PDBparameters['substrLength']

    def CreateSummaryFile(self,summaryFilePath):
        """
        Creates hhsearch summary file (hhsearchSummary.txt).  The query to 
        template alignment scores is extracted from all hhr files and written
        to the file hhsearchSummary.txt.  This allows for faster all against 
        all comparision for genome wide interaction predictions.

        Aguments:
            queryListFile (str): Full path to a file containg a new line
                delimited list of all gene names.  HHsearch should have
                already been preformed before running this script
        Modifies 
            hhsearchSummary.txt (file): Newline delimited list containing
                three pieces of information per line: the gene name, the
                matching template in the pdb, and the alignment score.
        Notes:
            The alignment score used is decided by the variable
            self.variableName.  This can be changed in springConfig.
            The three options for variables are in springConfig.genomeParameters

        Steps:
        1. Read in hhr file.
        2. Filter results based on variable threshold
        3. Write results summary to file.
        """
        f = open(self.query)
        count = 1
        fout = open(summaryFilePath,'w')
        fout.write(' '.join(['#GeneName','Template',self.variableName])+'\n')
        writeScientificNotation = False
        if self.variableName == 'Evalue':
            writeScientificNotation = True

        for line in f:
            target = line.strip()
            print(target,count)
            count += 1
            if not self.hhrFileExists(target):
                print("Warning hhr file for ",target,"not found")
                continue
            hhrFile = self.GethhrFilePath(target)
            hhrData = HHSEARCH_Functions(hhrFile,GetAlignmentData=False)
            if self.variableName == 'Evalue':
                hhrHits = hhrData.summary[['Template',self.variableName]][     
                    hhrData.summary[self.variableName] <= self.variableCutoff]
            else:
                hhrHits = hhrData.summary[['Template',self.variableName]][     
                    hhrData.summary[self.variableName] >= self.variableCutoff]

            if not hhrHits.empty:
                self.WriteSummaryFileHHR(target,hhrHits,fout,
                   writeScientificNotation=writeScientificNotation)

        f.close()
        fout.close()

    def RunSpringGenome(self,hhrSummaryFile,resultFilePath):
        """
        Uses hhsearch threading results for each protein sequence along with 
        protein protein interaction library to predict if two proteins 
        interact.

        Argument:
            resultFilePath (str): Full path of file where summary of results
                will be written

            hhrSummaryFile (file): Path to hhrSummary.txt. Its a 
                newline delimited list containing three pieces of information 
                per line: the gene name, the matching template in the pdb, 
                and the alignment score.

        Notes:
            The summary file shold have already been created.

        Modifies:
            predictedInteractions.txt (file): A file containing a list of
                predicted protein protein interactions along with the
                best corresponding hit.
            interactions/gene/gene.int (file):

        Steps:
            1. Store Concatenated Summarized results from hhsearch.
            2. Store SPRING index file used to check for interactions.
            3. Search interaction library
            4. Extract interaction results
            5. Write results to file
        """
        print("Storing summary results file")
        hhrSummary = self.StoreSummary(hhrSummaryFile)
        self.StoreIndex(self.indexFile)
        count = 1
        mkdirs(self.interactionsDir)
        foutSummary = open(resultFilePath,'w')
        writeScientificNotation = False
        if self.variableName == 'Evalue':
            writeScientificNotation = True
        for receptor in hhrSummary:
            print(receptor, count)
            count += 1
            for ligand in hhrSummary:
                interactionResults1=self.SearchIndex(receptor,ligand,hhrSummary)
                interactionResults2=self.SearchIndex(ligand,receptor,hhrSummary,
                                            reversedOrder=True)

                interactionResults,mostConfidentPred = self.ExtractInteractions(
                                        interactionResults1,interactionResults2)

                if not interactionResults: #if no templates found
                    continue
                print(receptor,ligand,' have interaction template')
                self.WriteOutput(receptor,ligand,interactionResults,
                    writeScientificNotation=writeScientificNotation)
                self.WriteOutputSummary(receptor,ligand,
                    mostConfidentPred,foutSummary)
        foutSummary.close()

    def WriteOutput(self,receptor,ligand,interactionResults,
        writeScientificNotation=False):
        """
        Writes a lists of all proteins predicted to bind to
        the receptor protein.  The name of the file is the 
        recetor protein.  It contains a list of all ligand
        proteins, the template used for the prediction and
        the threading confidence from hhsearch.
        """
        start = self.substrPos
        end = self.substrPos+self.substrLen
        outputDir = self.interactionsDir+'/'+receptor[start:end]+'/'
        mkdir(outputDir)
        filePath = outputDir+'/'+receptor+'.int'
        fout = open(filePath,'w')
        writeFormat = '%9.3f'
        if writeScientificNotation:
            writeFormat ='%9.3e'
    
        for interaction in interactionResults:
            templateName, score = interaction
            fout.write(ligand+' '+templateName+' '+writeFormat%score)
            fout.write('\n')
        fout.close()

    def WriteOutputSummary(self,receptor,ligand,mostConfidentPrediction,
        foutSummary,writeScientificNotation=False):
        """
        Writes a list of predicted interactions using the highest 
        confident template.

        Argument:
            receptor (str): Name of receptor protein
            ligand   (str): Name of ligand protein
            mostConfidentPrediction ( (str,float) ): Tuple containing
                the template name and alignment score for the best 
                template to query alignment.
        """ 
        writeFormat = '%9.3f'
        if writeScientificNotation:
            writeFormat ='%9.3e'
    
        templateName, score = mostConfidentPrediction
        foutSummary.write(receptor+' '+ligand+' '+templateName+' ')
        foutSummary.write(writeFormat%score)
        foutSummary.write('\n')


    def ExtractInteractions(self,interactions1, interactions2):
        """
        Remove redundancies and screen based on variable cutoff

        Arguments:
            interactions1 and interactions2 ( [[core,patner,scoreA,scoreB] ] ): 
                A list of templates and alignment scores from the complex 
                template search.  interactions1 is searching using the receptor
                and filters with the ligand.  interactions2 searches first using
                the ligand than filtered using the receptor

        Returns:
            outList
            mostConfidentPrediction
        """
        max_min = min
        if self.variableName == 'Evalue':
            max_min = max

        #(12e8L,1_0_0,12e8L)
        outList = []
        interactionHit = {}
        for interaction in interactions1:
            core,partner,refAscore,refBscore = interaction
            pdbA,bioMolA,refA = core
            pdbB,bioMolB,refB = partner
            keyA = (pdbA,bioMolA,pdbB,bioMolB)
            keyB = (pdbB,bioMolB,pdbA,bioMolA)
            interactionHit[keyA] = None
            interactionHit[keyB] = None
            score = max_min(refAscore,refBscore)
            templateName = pdbA+'/'+bioMolA+'-'+pdbB+'/'+bioMolB
            outList.append([templateName,score])

        for interaction in interactions2:
            core,partner,refAscore,refBscore = interaction
            pdbA,bioMolA,refA = core
            pdbB,bioMolB,refB = partner
            keyA = (pdbA,bioMolA,pdbB,bioMolB)
            keyB = (pdbB,bioMolB,pdbA,bioMolA)
            if keyA in interactionHit or keyB in interactionHit:
                continue
            score = max_min(refAscore,refBscore)
            templateName = pdbA+'/'+bioMolA+'-'+pdbB+'/'+bioMolB
            outList.append([templateName,score])

        mostConfidentPrediction = []
        if outList:
            if self.variableName == 'Evalue':
                mostConfidentPrediction = min(outList,key=lambda item:item[1])
            else:
                mostConfidentPrediction = max(outList,key=lambda item:item[1])
            
        return outList, mostConfidentPrediction


    def WriteSummaryFileHHR(self,target,hhrHitList,fout,
        writeScientificNotation=False):
        """
        Writes summarized hhr results for all genes to file.

        Arguments:
            target (str): Name of protein sequence that was threaded
            hhrHitList (pandas data frame): Dataframe containing
                the identified template and alignment
                score from hhsearch.  The items in the list passed the filter
                cutoff.
            fout (file handler): object used to write information to file

        Modifies:
            hhrSummaryFileName (file): Writes summary results to this file
        """
        writeFormat = '%9.3f'
        if writeScientificNotation:
            writeFormat = '%9.3e'

        for i in xrange(0,len(hhrHitList) ):
            templateName,score = hhrHitList.iloc[i]
            fout.write(' '.join([target,templateName,writeFormat%score]) )
            fout.write('\n')

    def GethhrFilePath(self,target):
        """
        Returns path to hhsearch results file of target
        """
        start = self.substrPos
        end = self.substrPos+self.substrLen
        hhrFilePath = self.hhrPath+'/'+target[start:end]+'/'+target+'.hhr'
        return hhrFilePath


    def hhrFileExists(self,target):
        """
        Checks for existance of results file
        """
        filePath = self.GethhrFilePath(target)
        if os.path.exists(filePath):
            return True
        else:
            return False


    def StoreSummary(self,hhrSummaryFile):
        """
        Store hhsearchSummary into hhrSummary dicitionary.
        Aguments:
            hhrSummaryFile (str): Full path to hhsearchSummaryFile.
        Returns:
            hhrSummary (dict): keys are protein names, values are a list
                of coresponding templates and its alignment score from
                threading ie hhrSummary['abde'] = [ ['12asA',0.95],.,
                                                    ['11asA',0.85] ]
        """
        f = open(hhrSummaryFile)
        headerLine = f.readline()

        hhrSummary = {}
        for line in f:
            target,template,score = line.split()
            score = float(score)
            if target not in hhrSummary:
                hhrSummary[target] = [ [template,score] ]
            else:
                hhrSummary[target].append([template,score])
        return hhrSummary


    def StoreIndex(self,indexFile):
        """
        This function stores the spring index file.

        File Format for index.txt
        
        Example segment from index.txt file             
        column1  column2   column3
        12e8H    0_0_0     12e8L
        12e8H    0_1_2     12e8L
        12e8H    0_1_3     12e8H
        137lA    0_0_0     137lA
        137lA    0_1_1     212lA
        137lA    1_0_0     137lA
        137lA    1_1_1     212lA
        12e8L    1_0_0     12e8L
        12e8L    1_1_1     12e8H

        The index.txt has three columns:

        Column 1 is the core pdb chain.  Every row that 
        has the same core pdb chain refers to an interaction
        involving that chain.

        Column2: contains three pieces of information.
        biomolecule_CoreOrPartner_chainNumber
            
        biomolecule refers to which biomolecule the interaction
        comes from.  Each pdbfile has one or several biomoleulces. 
        Each biomolecule is a different set of possilby biologically 
        relevant orientations of each macromolecule with respect to 
        one another.  For example one PDB file may contain a dimer
        with two biomolecules.  Each biomolecule representing a different
        interface.  As you can from the example above 11gsA only has
        one biomolecule designated with a 0 where as 137lA has two 
        biomolecules designated with a 0 and 1.

        CoreOrPartner refers to a row being a core or a partner.  For
        example 12e8H has three rows.  The first row with 0_0_0 was 
        the chain selected to check for interactions (the core).  
        Every macromolecule in contact with it is considered to be
        a partner.  Here the core is designated with a 0.  This
        core has two binding partners.  Each binding partner is
        designated with the number 1.

        chainNumber refers to the order of chains in a pdb file.
        The first chain is 0 the second is 1 and so on.  In the
        12e8H rows the pdb file contains 4 chains, but only the
        last two are involved in interactions with the first chain.
        So there is no interaction of the core with the second
        chain in the PDB file.

        Column 3 contains the reference pdb.  Each pair of sequences
        is searched as monomers through a monomeric database containing
        pdbs found in the reference column. For example if a query
        sequence matches to 12e8L all of the rows containing 12e8H
        and 12e8L in the first column would be used as for further 
        evaluation as a complex template because the both have core
        pdbs that share the 12e8L as a reference.  Each reference
        in column 3 shares a high degree of sequence and structural
        similarity to the pdb chain in column 1.   

        Modifies:  
            RefCoreToChain (dictionary): For each reference a list
                of all pdbchains that it references are stored.
                The list is actually another dictionary to allow
                for faster comparision. 
                Example Structure:
                RefCoreToChain[referencePDB] = {core1:None,core2:None,...}
            bioMolecule (dictionary): For each core a list (stored as a dictionary),
                of each biomolecules is stored. Each biomolecule points to 
                a list containing three values [core,[partners],number interactions]
                The core is the core pdb stored as a tuple containing the row
                information found in index.txt.  The second value is a list of
                all partners.  Each partner is stored as a tuple containing its
                respective row data from index.txt.  Finally the third value is
                number of interactions for the core.
                Example Structure:
                bioMolecule[core][biomoleculeNumber] = [chain,[partner],numInteractions]
                bioMolecule['12e8L'][1] = [(12e8L,1_0_0,12e8L),[(12e8L,1_1_1,12e8H)],1] 
        """
        f = open(indexFile)
        for line in f:
            tmp = line.split()
            coreChain = tmp[0]
            chainInfo = tmp[1] #biomolecule_core/partner_chainNum
            repChain = tmp[2]
            chain = (coreChain,chainInfo,repChain)

            tmp = chainInfo.split('_')
            bioMolecule = int(tmp[0])
            CoreOrPartner = int(tmp[1])
            chainNum = int(tmp[2])
            #store reference -> to all pdb chain it references  
            if repChain not in self.RefCoreToChain and CoreOrPartner == 0:
                self.RefCoreToChain[repChain] = {}

            if CoreOrPartner == 0:
                if coreChain not in self.RefCoreToChain[repChain]:
                    self.RefCoreToChain[repChain][coreChain] = None


            if coreChain not in self.BioMol:
                if CoreOrPartner == 0:
                    self.BioMol[coreChain] = {bioMolecule:[chain,[],0]}
                else:
                    self.BioMol[coreChain] = {bioMolecule:['',[chain],1]}   
            else:
                if bioMolecule in self.BioMol[coreChain]:
                    if CoreOrPartner == 0:
                        self.BioMol[coreChain][bioMolecule][0] = chain
                    else:
                        self.BioMol[coreChain][bioMolecule][1].append(chain)
                        self.BioMol[coreChain][bioMolecule][2] += 1
                else:
                    if CoreOrPartner == 0:
                        self.BioMol[coreChain][bioMolecule] = [chain,[],0]
                    else:
                        self.BioMol[coreChain][bioMolecule] = ['',[chain],1]
        f.close()


    def SearchIndex(self,receptor, ligand,hhrSummary,
        reversedOrder=False):
        """
        Returns a list of interactions that are found using the reference
        lookup search.

        Arguments:
            receptor and ligand (str): Name of protein
            hhrSummary (dictionary): the keys are the names of proteins. The
                dictionary stores a list of templates and threading scores
                generated from aligning the query proteins to the hhsearch
                database.  ie hhrSummary[receptor] ==[[template,alignmentScore]]
        Returns:
            complexList=[ [core,partner,coreZscore,partnerZscore,] ]
            complexList are all complex templates found in index who 
                have core reference chains belonging to receptor and 
                binding partners references belonging to ligand.  
                The data contained in core and partner are described
                in the StoreIndex function that is a part of the 
                spring module.
        Notes:
            The similarity scores contained in complexList are from the 
            hhr results file from running hhsearch
        """
        Btemplates = {}
        coreList = []
        complexList = [] #[ [core,partner,coreZscore,partnerZscore] ]
        bList = hhrSummary[ligand] 
        for i in xrange(0,len(hhrSummary[ligand])):
            reference = bList[i][0]
            score =  bList[i][1]
            Btemplates[reference] = score

        aList = hhrSummary[receptor]
        for i in xrange(0,len(hhrSummary[receptor])):
            reference = aList[i][0]
            score = aList[i][1]
            values = [reference,score]
            if reference in self.RefCoreToChain:
                for coreChain in self.RefCoreToChain[reference]:
                    coreList.append(values)
        if not coreList:
            return complexList

        coreHit = {}
        for coreData in coreList:
            reference = coreData[0]
            refAscore = coreData[1]
            for coreChain in self.RefCoreToChain[reference]:
                if coreChain in coreHit:
                    continue
                #print(coreChain)
                coreHit[coreChain] = None
                if coreChain not in self.BioMol:
                    continue
                for biomol in self.BioMol[coreChain].keys():
                    interactions = self.BioMol[coreChain][biomol]
                    core = interactions[0]
                    partners = interactions[1]
                    numberInteractions = interactions[2]
                    partnerList = []
                    for partner in partners:
                        partnerCore = partner[0]
                        partnerBioMol_CoreOrPartner_chainNum = partner[1]
                        partnerRef = partner[2]
                        if partnerRef in Btemplates:
                            values = Btemplates[partnerRef]
                            refBscore = values
                            if reversedOrder:
                                complexList.append([partner,core,refBscore,
                                    refAscore])
                            else:
                                complexList.append([core,partner,refAscore,
                                    refBscore])
        return complexList

def ParseCommandLine():
    """
    Parses command line for arguments for running COTH.py
    
    Returns:
        args (Namespace for argparse): This namespace will contain all the 
        parameters from the command line
    """
    defaultParam = springConfig.parameters
    parser = argparse.ArgumentParser(prog = os.path.basename(__file__),
                description=__doc__,
                formatter_class=argparse.RawDescriptionHelpFormatter)
    #Required Arguments
    arguments = parser.add_argument_group(title='Arguments')

    queryHelp = "Full path to query file ie. -q "\
            "/home/username/querylist.txt where querylist.txt is a newline "\
            "delimited list of targets ie 117eA 117eB 12asA etc."

    arguments.add_argument('-q',action="store",required=True,help=queryHelp)

    runHelp = "Argument for deciding which operation to run. GetSummary " \
        "concatenates all hhsearch results files into one summary file. " \
        "PredictInteractions reads in the summary file and predicts " \
        "All pairwise interactions using spring"

    arguments.add_argument('-r',action='store',required=True,
            choices =['GetSummary','PredictInteractions'],help=runHelp )

    inputDirHelp = "The directory that contains all the input data. "\
            "The fasta, hhm and hhr directories should all be located in"\
            "  the input directoriy ie if the fasta directory "\
            "is at /home/user/fasta/ then  -iDir /home/user/."
    arguments.add_argument('-iDir',action="store",required=True,
            help=inputDirHelp)

    summaryFileHelp = "Optional. Full path to where summaryFile is written " \
        "Default is inputDirectory/hhsearchSummary.txt "

    arguments.add_argument('-sf',action='store',required=False,
            help=summaryFileHelp,default='')

    resultsFileHelp = "Optional. Full path to where summary of predicted " \
        "interactions file is written.  Default is inputDirectory/" \
        "predictedInteractions.txt"
    arguments.add_argument('-rf',action='store',required=False,
            help=resultsFileHelp,default='')

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)
    args = parser.parse_args()
    return args

if __name__ == '__main__':
    args = ParseCommandLine()
    queryFile = args.q
    runType = args.r
    inputDirectory = args.iDir
    summaryFile = args.sf
    resultsFile = args.rf

    if summaryFile == '':
        summaryFile = inputDirectory+'/hhsearchSummary.txt'
    if resultsFile == '':
        resultsFile = inputDirectory+'/predictedInteractions.txt'

    if runType == 'GetSummary':
        gwMod = SPRING_GENOME(queryFile,inputDirectory)
        gwMod.CreateSummaryFile(summaryFile)
    elif runType == 'PredictInteractions': 
        gwMod = SPRING_GENOME(queryFile,inputDirectory)
        gwMod.RunSpringGenome(summaryFile,resultsFile)

    else:
        print("Invalued runType used please use -r GetSummary or -r ",
            "PredictInteractions")
